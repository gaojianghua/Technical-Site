# 输入URL到看到页面

1. URL解析
   - 传输协议: 用什么样的协议负责客户端和服务端的信息传输
     - HTTP: 最常用的超文本传输协议  HTTP1.0/1.1/2.0
     - HTTPS: HTTP+SSL(TSL)比HTTP更安全
     - FTP: 文件的上传下载
   - 域名: 对服务器外网IP的一个重命名
     - 顶级域名 (qq.com) 一级域名 (www.qq.com) 二级域名 (graph.qq.com)
   - 端口号: 区分同一台服务器上不同的服务的
     - 0~65535之间
     - 默认端口号: 浏览器会根据输入的协议, 给予默认端口号[前提是自己没有指定]
       1. HTTP => 80
       2. HTTPS => 443
       3. FTP => 21
   - 请求资源的文件路径
     - URL重写
       1. 动态网址(https://item.jd.com/detail.jsp?id=123) 不被搜索引擎收录, 不利于SEO优化
       2. 动态网站静态化, 重写URL(https://item.jd.com/123.html) 可被收录, 有利于SEO优化
   - 问号参数
     - 客户端把信息传递给服务器
     - A页面把信息传递给B页面
     - A组件把信息传递给B组件
   - 哈希值 HASH
     - 描点定位
     - HASH路由
   - 编码问题
     - 处理: 中文、特殊字符
       1. encodeURI/decodeURI: 对整个URL编码, 处理中文
       2. encodeURIComponent/decodeURIComponent: 对传递的参数单独的编码, 处理中文以及特殊符号
       3. escape/unescape: 客户端对中文进行编码解码 [一般只用于客户端信息传输, 例如: cookie]



2. 缓存检测

   - 缓存一般指的都是静态资源文件的缓存, 这个一般是客户端和服务器端根据一些协商规则, 自动去完成的缓存策略 [不用我们自己写代码去处理]

   - 只有API接口数据缓存, 是需要前端开发自己去完成的

   - 缓存位置

     - Memory Cache: 内存缓存 [一般用于页面没有关闭, 只是刷新]
     - Disk Cache: 硬盘缓存 [用于页面关闭后重新打开还在]

   - 缓存处理

     先看是否存在强缓存 [强缓存存在, 走强缓存] => 强缓存不存在, 再看是否有协商缓存 [协商缓存存在, 走协商缓存] => 协商缓存不存在, 则直接从服务器获取最新的内容 => 缓存获取的最新内容

     - 强缓存 Expires [HTTP1.0]  /  Cache-Control [HTTP1.1]
       1. 强缓存中获取的信息与服务器重新获取的, HTTP状态码都是200
       2. 强缓存不适合静态页面的缓存
          - 如果页面缓存了, 服务器更新产品, 我们访问还是走的缓存, 这样看不到最新内容
          - [CSS/JS/图片...]一般会走强缓存, 在对应的资源名称后面加上时间戳或者hash戳, 发现与上次的名称不一样就从新拉取最新信息
     - 协商缓存 Last-Modified/If-Modified-Since  [HTTP1.0]  &  ETag/If-None-Match [HTTP1.1]  
       1. 静态页面可以使用协商缓存处理
       2. 对于其余的资源文件, 会使用强缓存+协商缓存

   - 数据缓存

     - 本地缓存: cookie / localStorage / sessionStorage
       - cookie: 存储内容很少, 上限4KB, cookie信息会默认在客户端和服务端传来传去 [内容信息多会影响前后端通信的速度], 不稳定 [基于安全卫士等可以将其清楚掉], 用户可以禁用cookie
       - localStorage : 存储内容上限5MB, 持久存储, 稳定, 和服务器端无关
       - sessionStorage: 存储内容上限5MB, 页面关闭则消失, 稳定, 和服务器端无关



3. DNS解析
   - 本地查找: 依次查找浏览器缓存 => 本地hosts文件 => 本地DNS解析器缓存 => 本地DNS服务器
   - 远端查找: 若本地未能找到, 则依次查找根域名服务器 => 顶级域名服务器 => 权威域名服务器
   - 每一次DNS解析在20~120毫秒
     - 减少DNS解析 [一个网站中访问的资源尽可能在一个服务器上]
   - DNS预获取 (DNS Prefetch)
     - 利用link标签的异步性, 在rel属性中填入dns-prefetch, href中填入域名即可, 在渲染页面的过程中, 同时去做DNS解析并缓存, 后期渲染直接拿缓存中的记录



4. TCP三次握手

   建立客户端与服务器之间的网络连接通道 [只有通道建立好, 才能基于HTTP/HTTPS传输信息]

   - TCP网络通信: 更加稳定可靠 [三次握手 & 四次挥手], 但是也会慢
     - seq序号: 用来标识从TCP源端向目的端发送的字节流, 发起方发送数据时对此进行标记
     - ack确认序号: 只有ACK标志位为1时, 确认序号字段才有效, ack=seq+1
     - 标志位
       - ACK: 确认序号有效
       - RST: 重置连接
       - SYN: 发起一个新连接
       - FIN: 释放一个连接
     - 握手过程
       1. 客户端发起一个连接(SYN=1)给服务器端, (seq=x)标识为客户端发送
       2. 服务器端收到后发起一个连接(SYN=1)给客户端, (seq=y)标识为服务器端发送, 并确认序号有效(ACK=1, ack=x+1)
       3. 客户端收到后通过确认序号有效知道了可以连接, 客户端再次发起连接给服务器端, 并确认序号有效(ACK=1, ack=y+1), 通知服务器端可以开始传输了
   - UDP网络通信: 虽然建立通道比较快, 但是不稳定, 信息传输过程中可能丢失信息
     - 通常用于语音、视频流的信息传输



5. 数据传输

   基于传输协议

   - HTTP事务: 一个完整的请求和响应, 称为一次HTTP事务
   - HTTP报文: 客户端和服务器之间通信的所有内容, 统称为HTTP报文 [控制台 NetWork]
     - 起始行: 请求起始行、响应起始行
     - 首部 (头) : 请求头 [Request Headers]、响应头 [Response Headers]
     - 主体: 请求主体、响应主体



6. TCP四次挥手
   - 挥手过程
     1. 客户端释放连接告诉服务器端(FIN=1), 标识客户端发送(seq=x)
     2. 服务器端确认客户端的通知有效(ack=x+1, ACK=1), 并发送数据传输给客户端
     3. 传输完成后服务器端释放连接告诉客户端(FIN=1), 标识服务器端发送(seq=y), 并再次确认客户端的通知有效(ack=x+1, ACK=1)
     4. 客户端确认服务器端的通知有效(ack=y+1, ACK=1), 标识客户端发送(seq=x+1)
   - Connection: keep-alive
     - 长连接 [保持TCP通道暂时不关闭]
     - HTTP1.1版本及以后, 默认都是带着这个属性
     - 手动关闭, 修改值为Close



7. 渲染页面

   - CRP critical rendering path ［关键渲染路径］

     从服务器基于HTTP网络请求回来的数据

     1. 16进制文件流
     2. 浏览器把它解析为字符串（HTML字符串）
     3. 按照W3C规则识别为一个个的节点［词法解析］
     4. 开始渲染页面

   - 渲染页面过程

     1. 遇到style内嵌样式, GUI直接渲染即可

     2. 遇到link, 浏览器开辟一个HTTP线程去请求资源文件信息, 同时GUI继续向下渲染 [异步]

        - 浏览器同时能够发送的HTTP请求是有数量限制的 (谷歌: 5~7个)
        - 超过最大并发限制的HTTP请求需要排队等待

     3. 遇到@import, 浏览器也是开辟HTTP线程去请求资源, 但是此时GUI会暂停

     4. 遇到script标签, 浏览器也是开辟HTTP线程去请求资源, 也会阻塞GUI渲染, 等到js文件请求回来会交给js引擎线程处理

        - ~~~js
          window.addEventListener('load', function () {
              // 等待页面所有资源加载完, 才会触发执行
          })
          window.addEventListener('DOMContentLoaded', function () {
              // 等待DOM树渲染完成, 才会触发执行, 优先于load
          })
          ~~~

        - script标签上的async属性: 单独开辟HTTP去请求js资源, 此时GUI继续渲染, 但是一但js请求回来, 会立即暂停GUI处理, 交给js引擎线程去处理js, 处理完后继续GUI渲染

        - script标签上的defer属性: 单独开辟HTTP去请求js资源, 不会阻塞GUI渲染, 等待所有js资源请求回来后, 再按照编写的依赖顺序去通知js引擎线程去执行

   - 总结步骤: 
     - 处理HTML标记, 构建DOM树
     - 处理CSS标记, 构建CSSOM树
     - 将DOM树和CSSOM树合并成渲染树
     - 根据生成的渲染树, 计算它们在设备视口(viewport)内的确切位置和大小, 这个计算的阶段就是回流=>布局(layout) 或重排(reflow)
     - 根据渲染树以及回流得到的几何信息, 得到节点的绝对像素=>绘制(painting)

   - 优化方案:
     - 标签语义化和避免深层次嵌套

     - CSS选择器渲染是从右到左

     - 尽早尽快的把CSS下载到客户端

     - 避免阻塞的js加载

     - 减少DOM的回流和重绘

       1. 浏览器渲染队列, 存储修改的样式, 当没有修改样式的代码后或者遇到获取样式的代码时会立即刷新浏览器渲染队列

       2. 集中改变样式

       3. 读写分离

       4. 缓存布局信息

       5. 元素批量修改 [文档碎片: createDocumentFragment, 模板字符串拼接]

       6. 动画效果应用到position属性为absolute或者fixed的元素上(脱离文档流)

       7. CSS3硬件加速(GPU加速不会引发回流和重绘, 过多使用会占用大量内存, 性能消耗严重)

       8. 避免table布局和使用css的js表达式



## HTTP版本间的区别

1. HTTP1.0和HTTP1.1的区别

   - 缓存处理
     - HTTP1.0中主要使用Last-Modified, Expires来做为缓存判断的标准
     - HTTP1.1则引入了更多的缓存控制策略: ETag, Cache-Control
   - 带宽优化及网络连接的使用
     - HTTP1.1支持断点续传, 即返回码是206 (Partial Content)
   - 错误通知的管理
     - 在HTTP1.1中新增了24个错误状态码, 如409(Conflict)表示请求的资源与资源的当前状态发送冲突; 410(Gone)表示服务器上的某个资源被永久性删除

   - Host头处理
     - 在HTTP1.0中认为每台服务器都绑定一个唯一IP地址, 因此, 请求消息中的URL并没有传递主机名(hostname), 但随着虚拟主机技术的发展, 在一台服务器上可以存在多个虚拟主机, 并且他们共享一个唯一IP地址, HTTP1.1的请求消息和响应消息都应支持Host头域, 且请求消息中如果没有Host头域会报告一个错误(400 Bad Request)
   - 长连接
     - HTTP1.1中默认开启Connection: keep-alive, 一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点

2. HTTP2.0和HTTP1.X的区别

   - 新的二进制格式
     
     - HTTP1.X的解析是基于文本, 基于文本协议的格式解析存在天然缺陷, 文本的表现形式是多样性, 要做到健壮性考虑的场景必然很多, 二进制则不同, 只认0和1的组合, 基于这种考虑HTTP2.0的协议解析决定采用二进制格式, 实现方便且健壮
   - header压缩
     
     - HTTP1.X的header带有大量信息, 而且每次都要重复发送, HTTP2.0使用encoder来减少需要传输的header大小, 通讯双方各自cache-份header fields表, 即避免了重复header的传递, 又减少了需要传输的大小
   - 服务端推送
     - 例如我的网页有一个style.css的请求, 在客户端收到style.css数据的同时, 服务端会将style.js的文件推送给客户端, 当客户端再次尝试获取style.js时就可以直接从缓存中获取到, 不用再发请求了
     - ~~~js
       // 通过在应用生成HTTP响应头信息中设置Link命令
       Link: </styles.css>; rel=preload; as=style; </example.png>; rel=preload; as=image
       ~~~
   - 多路复用
     - HTTP1.0: 每次请求响应, 建立一个TCP连接, 用完关闭
     - HTTP1.1: [长连接] 若干个请求排队串行化单线程处理, 后面的请求等待前面请求的返回才能获得执行机会, 一旦有某请求超时等, 后续请求只能被阻塞, 毫无办法, 也就是人们常说的线头阻塞
     - HTTP2.0: [多路复用] 多个请求可同时在一个连接上并行执行, 某个请求任务耗时严重, 不会影响到其他连击的正常执行